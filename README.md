## 用户登录态的管理
### 各种token相比于Session的优点和缺点：

#### 短token
- 优点1.tooken是计算型令牌，存在客户端，每次都是由服务端计算进行校验，不需要服务端储存，节省空间。
- 优点2.能解决分布式系统下session可能会失效的问题
- 缺点1.只存了用户的id，如果登陆成功后需要用户的其他数据，还得用id去查，虽然节约空间但是浪费cpu
- 缺点2.不好设定过期时间，时间长了不安全，时间短了用户体验不好。

#### 长token（过期时间比较长的计算型令牌
- 长token的内容和短token一样，都是 `id` 和 `过期时间` 和两者加密后的数字签名  
- 但是这次同时使用redis，虽然token只有用户id，但是我们同时在redis中存一个key为 `uesr:id` ,v为 `存储user信息的json字符串`，这样我们校验完token之后就能通过token中的 `userId` 直接去redis中拿用户的所有信息，这样就能节省从MySQL中查询用户信息的时间和性能。而且后续可以结合redis，进行用户的数据采集，从而做个性化推荐。  
- 缺点就是过期时间长，不够安全。
#### 长短token
    版本答案
- 给出两个token，短token过期时间一般是半小时，长token过期时间是几个月甚至几年。两个token都会在登陆成功后在客户端进行存储。  
- 短token的结构和之前一样，只保存在客户端，长token的结构是 `一个随机的串` + 这个串加密后的数字签名。  
- 流程：

    - 客户端发起登录请求，我们的接口处理这个请求，生成短token放入cookie中， 生成长token放入cookie和redis中，并且给这个key设置过期时间。
    - 客户端后续请求都会携带长短token
    - 服务端收到请求，如果这次请求访问的接口带有 `需要登录才能访问` 的注解，那我们会对长短token进行校验。  
    
        - 校验长token，如果没有长token或者长token不合法或者过期直接重新登录。
        - 校验短token，如果没有短token或者短token过期，且长token校验通过，就重新根据redis中的json数据生成一个短token，也叫无感刷新。
        - 如果短token非法，重新登录。
## 用户登陆方式的管理
1、用户名+密码  
- 密码要二次加密
    
    - 第一次加密是前端加密，为了防止在 客户端生成的报文 和 服务端解析的报文 被人获取到。
    - 服务端加 `salt` 加密，为了防止数据表被 `撞库` (彩虹表)。

2、邮箱+验证码  

- 校验邮箱是否合法（正则）
- 校验邮箱是否被注册过（注册过的邮箱都缓存在redis中，如果redis中的邮箱缓存没有这个value，证明没有被注册过）  
- 发送邮件之后同时把验证码存在redis中进行对比，还方便定期对验证码进行删除
- 验证码除了定期删除以外，被使用过的验证码要立即删除，防止用户在上一个验证码还没过期的时候又发了另一个功能的验证码（如注册收到验证码之后立即又去忘记密码再收个验证码）

3、手机+验证码  
> 现在的手机验证码登录的逻辑都是 如果我们用户表中没有这个手机号，我们就立即为这个手机号准备用户信息，后续的字段可以让他去修改，一些关键字段可以随机生成(如用户名)。  
> 如果用户表中有这个信息，那就正常用双token的思想处理用户登录态
- 流程和邮箱登录差不多

4、第三方授权  

- 第三方授权主要有两种方式

    - 调用本地进程（网页版qq邮箱的登录）
    - 扫码登录
- 第三方授权往往要企业资格认证（搞不到）

## 时限内免登录
- 在token校验合法之后去redis中获取用户即可  

    - 能获取到的直接放行，并且重置过期时间，实现一段时间内免登录
    - 获取不到就重新登录
## 秒杀基本逻辑
- 流程  

    - 先写基本逻辑，看QPS（服务器每秒能处理的请求数量）
    - 每优化一点，看看优化后的QPS  
- 秒杀必做的三步

    - 商品库存减扣
    - 用户限购判断
    - 下订单，并且把订单信息返回给前端，渲染出此次购买的订单详情信息，让用户准备支付
- 一共做四个数据表，商品表，秒杀商品表，订单表，秒杀订单表。

  - 商品表分两个原因是字段不同，比如秒杀商品要有秒杀开始时间和截至时间。
  - 订单表因为秒杀订单比较少，如果订单量很大，这个时候如果有业务需求找到所有秒杀订单，那就只能扫描全表，可能在几万条数据里插十几条，不如单独分出一张表。
- 在用户点击秒杀的时候，如果能抢到锁，直接为用户锁定库存(商品库存-1)，并且创建订单。抢不到就告诉用户系统繁忙稍后再试
- 把这个订单放入30分钟的延迟队列中
- 如果用户中途支付或者取消订单，把对应订单的状态改为已支付或者已取消。
- 超过30分钟，订单来到消费者这里，我们拿出这个订单对象，用他的id查数据库里对应的订单的状态
- 每次秒杀的时候判断当前时间是不是再活动期间
- 下单成功可以提示 `已为您锁定库存，请到订单中心进行支付` 
- 订单超时了别忘了把库存加回去
- 

> spring bean的作用域：单例的    原型的（多例的）  
> 单例的bean在IOC容器初始化的时候初始化，原型的bean在使用的时候初始化
## 内存标记：尽可能减少网络消耗  

  - 注入一个Map到IOC
  - redis初始化数据库的时候初始化map
  - redis库存扣减到0的时候 更改map的v
  - 所有库存的判断都通过map的标记判断
  - 为防止超卖，又加了锁
  - 目前QPS 3200左右
## 订单优化：rabbitMQ异步 前端轮循 获取最终结果
## 限购处理
- 通过判断订单里有没有对应的userId实现
- 用户下单后向redis中缓存一个key
## 分布式锁
- redis实现分布式锁（单机）
- 保证redis命令原子性，两种方式

  - Pipeline（管道）
  - Lua脚本
- 为什么不用Pipeline

  - Pipeline不够灵活，MySQL的存储过程可以在内部写流程结构， `根据当前的值决定下一步操作` ，
  但是Pipeline不行，它的流程结构是固定的，不够灵活。
- 使用redis分布式锁后，目前QPS 5800左右
## rabbitMQ异步下单
- 生产者生产了消息，但是消费者拿不到
- 生产者生产了消息，但是消费者消费失败了
- 实现生产者的可靠发送
------------------------------
下单应该准备两个队列，一个普通队列用于生产和消费订单，一个延迟队列用于判断订单超时